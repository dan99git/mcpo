<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCPO - ChatGPT Style UI</title>
    <style>
        /* ChatGPT Design System */
        :root {
            /* Light theme */
            --bg-primary: #ffffff;
            --bg-secondary: #f9f9f9;
            --bg-tertiary: #f1f1f1;
            --text-primary: #2f2f2f;
            --text-secondary: #646464;
            --border: #e5e5e5;
            --border-light: #f0f0f0;
            --hover: #f5f5f5;
            --active: #ececec;
            --success: #10a37f;
            --error: #dc3545;
        }

        [data-theme="dark"] {
            /* Dark theme */
            --bg-primary: #212121;
            --bg-secondary: #2f2f2f;
            --bg-tertiary: #424242;
            --text-primary: #ececec;
            --text-secondary: #b3b3b3;
            --border: #4a4a4a;
            --border-light: #3a3a3a;
            --hover: #2a2a2a;
            --active: #353535;
            --success: #10a37f;
            --error: #dc3545;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "S√∂hne", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
            line-height: 1.4;
            height: 100vh;
            /* allow full page scrolling for taller editors */
            overflow-y: auto;
        }

        .app {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 240px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        /* Dark mode specific sidebar override */
        [data-theme="dark"] .sidebar {
            background: #000; /* pure black for contrast */
            border-right: 1px solid #1e1e1e;
        }

        .sidebar-header {
            padding: 12px;
            border-bottom: 1px solid var(--border);
        }

        .app-title {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: none;
        }

        .logo-circle {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .logo-text {
            flex: 1;
            min-width: 0;
            display: flex;
            align-items: center;
            font-size: 24px;
            font-weight: 600;
            color: var(--text-primary);
            line-height: 32px;
            margin-left: 2px;
            white-space: nowrap;
            overflow: hidden;
        }

        .sidebar-nav {
            flex: 1;
            padding: 6px 8px;
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 13px;
            margin-bottom: 1px;
            transition: all 0.2s;
        }

    /* Force black font for sidebar items in light theme */
    body[data-theme="light"] .sidebar .nav-item { color: #000 !important; }
    body[data-theme="light"] .sidebar .nav-item.active { color: #000 !important; }

        .nav-item:hover {
            background: var(--hover);
        }

        .nav-item.active {
            background: var(--active);
            color: var(--text-primary);
        }

        .nav-icon {
            width: 14px;
            height: 14px;
            opacity: 0.7;
        }

        .sidebar-status {
            padding: 8px 12px;
            border-top: 1px solid var(--border);
            font-size: 11px;
            color: var(--text-secondary);
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }

        .sidebar-footer {
            padding: 8px 12px;
            border-top: 1px solid var(--border);
        }

        .theme-toggle {
            width: 100%;
            padding: 6px 10px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            font-weight: 500;
            transition: background .2s, border-color .2s;
        }

        .theme-toggle:hover {
            background: var(--hover);
            border-color: var(--text-secondary);
        }

        .theme-indicator {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #ff9800; /* orange accent */
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .theme-indicator svg { width: 16px; height: 16px; display: block; }

        .theme-label { flex: 1; text-align: left; }

    .nav-emoji { font-size: 14px; line-height: 1; display: flex; align-items: center; font-family: 'Segoe UI Emoji','Apple Color Emoji','Noto Color Emoji','EmojiOne Color','Twemoji Mozilla',sans-serif; }

        /* Sidebar typography tweaks to mimic official docs */
        .sidebar-nav, .sidebar-status {
            font-family: "Inter", "InterVariable", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
            letter-spacing: .2px;
        }
        .sidebar-nav .nav-item { font-weight: 500; }

        /* Main Content */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
        }

        .main-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            background: var(--bg-primary);
        }

        .page-title {
            font-size: 32px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .page-subtitle {
            color: var(--text-secondary);
            font-size: 16px;
            line-height: 1.4;
        }

        .main-content {
            flex: 1;
            padding: 16px 20px;
            overflow-y: auto;
        }

        /* Page Content */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        /* Cards */
        .card {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .card-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .card-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .card-content {
            padding: 0;
        }

        /* Server Items */
        .server-item {
            border-bottom: 1px solid var(--border-light);
        }

        .server-item:last-child {
            border-bottom: none;
        }

        .server-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 16px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .server-header:hover {
            background: var(--hover);
        }

        .server-info {
            flex: 1;
            min-width: 0;
        }

        .server-name-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 2px;
        }

        .server-name {
            font-weight: 500;
            font-size: 14px;
            color: var(--text-primary);
        }

        .status-beacon {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .status-beacon.connected {
            background: var(--success);
        }

        .status-beacon.error {
            background: var(--error);
        }

        .status-beacon.hidden {
            display: none;
        }

        .server-status {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .tool-count {
            font-size: 10px;
            color: var(--text-secondary);
        }

        .server-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .expand-icon {
            width: 12px;
            height: 12px;
            color: var(--text-secondary);
            transition: transform 0.2s;
            margin-left: 8px;
        }

        .server-item.expanded .expand-icon {
            transform: rotate(90deg);
        }

        /* Tools Dropdown */
        .tools-dropdown {
            display: none;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-light);
            padding: 8px 16px 12px;
        }

        .tools-dropdown.expanded {
            display: block;
        }

        .tools-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .tool-tag {
            background: var(--bg-tertiary);
            padding: 3px 8px;
            border-radius: 8px;
            font-size: 10px;
            color: var(--text-secondary);
            border: 1px solid var(--border-light);
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            position: relative;
        }

        .tool-tag:hover {
            background: var(--hover);
            border-color: var(--border);
        }

        .tool-tag.enabled {
            background: var(--text-primary);
            color: var(--bg-primary);
            border-color: var(--text-primary);
        }

        .tool-tag.enabled:hover {
            background: var(--text-secondary);
        }

        .tool-tag.disabled {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border-color: var(--border);
            opacity: 0.6;
        }

        .tool-tag.disabled:hover {
            background: var(--hover);
        }

        .tool-tag.inactive {
            opacity: 0.5;
            pointer-events: none;
        }

        /* Compact Toggle Switch */
        .toggle {
            width: 32px;
            height: 18px;
            background: var(--border);
            border-radius: 9px;
            position: relative;
            cursor: pointer;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .toggle.on {
            background: var(--text-primary);
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background: white;
            border-radius: 50%;
            transition: transform 0.2s;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .toggle.on::after {
            transform: translateX(14px);
        }

        /* Compact Buttons */
        .btn {
            padding: 4px 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 11px;
            text-decoration: none;
            display: inline-block;
            transition: all 0.2s;
        }

        .btn:hover {
            background: var(--hover);
        }

        .btn-primary {
            background: var(--text-primary);
            color: var(--bg-primary);
            border-color: var(--text-primary);
        }

        .btn-primary:hover {
            opacity: 0.9;
        }

        /* Logs Page */
        .logs-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            height: 500px;
            display: flex;
            flex-direction: column;
        }

        .logs-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .logs-content {
            flex: 1;
            padding: 12px;
            overflow-y: auto;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.3;
        }

        .log-entry {
            margin-bottom: 4px;
            color: var(--text-secondary);
        }

        .log-timestamp {
            color: var(--text-secondary);
            opacity: 0.7;
        }

        .log-level {
            font-weight: 600;
            margin: 0 6px;
        }

        .log-level.info { color: var(--text-primary); }
        .log-level.error { color: var(--error); }
        .log-level.warning { color: #fd7e14; }

        /* Tools Warning */
        .tools-warning {
            background: rgba(255, 152, 0, 0.1);
            border: 1px solid rgba(255, 152, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin: 0 24px 16px 24px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .warning-icon {
            color: #ff9800;
            font-size: 16px;
            line-height: 1;
            margin-top: 2px;
        }

        .warning-content {
            flex: 1;
        }

        .warning-title {
            color: #ff9800;
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .warning-message {
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 1.4;
        }

        /* Config Page */
        .config-section {
            margin-bottom: 24px;
        }

        .section-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .section-description {
            color: var(--text-secondary);
            font-size: 12px;
            margin-bottom: 12px;
        }

        .config-editor {
            width: 100%;
            min-height: 220px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 11px;
            color: var(--text-primary);
            resize: vertical;
            outline: none;
            line-height: 1.4;
        }

        /* Larger initial height specifically for the main JSON config editor */
        .config-editor.json-editor {
            min-height: 420px;
        }

        .config-actions {
            margin-top: 12px;
            display: flex;
            gap: 8px;
        }

        /* Add Server Form */
        .add-server-form {
            display: none;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            margin-top: 12px;
        }

        .add-server-form.active {
            display: block;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            margin-bottom: 4px;
            font-weight: 500;
            color: var(--text-primary);
            font-size: 12px;
        }

        .form-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 12px;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--text-primary);
        }

        .form-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                position: absolute;
                left: -100%;
                z-index: 1000;
                transition: left 0.3s;
            }

            .sidebar.open {
                left: 0;
            }

            .main {
                margin-left: 0;
            }

            .main-content {
                padding: 12px;
            }
        }
    </style>
</head>
<body data-theme="light">
    <div class="app">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="app-title">
                    <img src="logos/OI-logo-light.png" alt="Logo" class="logo-circle">
                    <div class="logo-text">Open WebUI</div>
                </div>
            </div>

            <nav class="sidebar-nav">
                <div class="nav-item" data-page="docs">
                    <span class="nav-emoji" aria-hidden="true">üìñ</span>
                    <span>MCP Guide</span>
                </div>
                <div class="nav-item active" data-page="tools">
                    <span class="nav-emoji" aria-hidden="true">üîß</span>
                    <span>MCP Tools</span>
                </div>
                <div class="nav-item" data-page="logs">
                    <span class="nav-emoji" aria-hidden="true">üìú</span>
                    <span>Logs</span>
                </div>
                <div class="nav-item" data-page="config">
                    <span class="nav-emoji" aria-hidden="true">‚öôÔ∏è</span>
                    <span>Configuration</span>
                </div>
                <div class="nav-item" data-page="documentation">
                    <span class="nav-emoji" aria-hidden="true">üìÑ</span>
                    <span>Documentation</span>
                </div>
            </nav>

            <!-- System Status in Sidebar -->
            <div class="sidebar-status">
                <div class="status-row">
                    <span>Servers:</span>
                    <span id="server-count">3 active</span>
                </div>
                <div class="status-row">
                    <span>Tools:</span>
                    <span id="tool-count">8 enabled</span>
                </div>
                <div class="status-row">
                    <span>Uptime:</span>
                    <span>2h 14m</span>
                </div>
                <div class="status-row">
                    <span>Version:</span>
                    <span>0.0.18</span>
                </div>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" onclick="toggleTheme()" type="button" aria-label="Toggle theme">
                    <span class="theme-indicator" id="theme-indicator">L</span>
                    <span class="theme-label" id="theme-label">Light Theme</span>
                </button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main">
            <header class="main-header">
                <h1 class="page-title">MCPO</h1>
                <p class="page-subtitle">Expose any MCP tool as an OpenAPI-compatible HTTP server‚Äîinstantly.</p>
            </header>

            <main class="main-content">
                <!-- MCP Tools Page -->
                <div class="page active" id="tools-page">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Active Servers</h2>
                            <button class="btn" onclick="openConfigPage()">Configuration</button>
                            </div>

                        <!-- Tools Limit Warning -->
                        <div class="tools-warning" id="tools-warning" style="display: none;">
                            <div class="warning-icon">‚ö†Ô∏è</div>
                            <div class="warning-content">
                                <div class="warning-title">Exceeding total tools limit</div>
                                <div class="warning-message">You have <span id="total-tools-count">0</span> tools from enabled servers. Too many tools can degrade performance, and some models may not respect more than 40 tools.</div>
                                </div>
                            </div>

                        <div class="card-content">
                            <!-- Servers will be dynamically loaded here -->
                        </div>
                    </div>

                    <!-- Add Server Form removed per requirement -->
                </div>

                <!-- Logs Page -->
                <div class="page" id="logs-page">
                    <div class="logs-container">
                        <div class="logs-header">
                            <h2 class="card-title">Live Server Logs</h2>
                            <div style="display: flex; gap: 6px;">
                                <button class="btn" onclick="clearLogs()">Clear</button>
                                <button class="btn btn-primary" onclick="restartAllServers()">Restart All</button>
                            </div>
                        </div>
                        <div class="logs-content" id="logs-content">
                            <!-- Live logs will be loaded here -->
                            </div>
                    </div>
                </div>

                <!-- Configuration Page -->
                <div class="page" id="config-page">
                    <div class="config-section">
                        <h2 class="section-title">Server Configuration</h2>
                        <p class="section-description">Edit your mcpo.json configuration file. Changes will be applied automatically.</p>
                        
                        <textarea class="config-editor json-editor" id="server-config-editor">{
  "mcpServers": {
    "time": {
      "command": "uvx",
      "args": ["mcp-server-time"],
      "enabled": true
    },
    "perplexity": {
      "command": "npx",
      "args": ["-y", "perplexity-mcp"],
      "enabled": true,
      "env": {
        "PERPLEXITY_API_KEY": "your-api-key-here"
      }
    },
    "memory": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-memory"],
      "enabled": true
    }
  }
}</textarea>

                        <div class="config-actions">
                            <button class="btn" onclick="validateConfig()">Validate</button>
                            <button class="btn" onclick="resetConfig()">Reset</button>
                            <button class="btn btn-primary" onclick="saveConfigContent()">Save Configuration</button>
                        </div>
                    </div>

                    <div class="config-section">
                        <h2 class="section-title">Python Dependencies</h2>
                        <p class="section-description">Manage Python packages required by your MCP servers. One package per line.</p>
                        
                        <textarea class="config-editor" style="min-height: 120px;"># Python packages for MCP servers
requests>=2.25.0
pandas>=1.3.0
numpy>=1.21.0</textarea>

                        <div class="config-actions">
                            <button class="btn" onclick="installDependencies()">Install Dependencies</button>
                            <button class="btn btn-primary" onclick="saveRequirements()">Save Requirements</button>
                        </div>
                    </div>
                </div>

                <!-- Documentation Page -->
                <div class="page" id="documentation-page">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Understanding MCP Servers (Model Context Protocol) in Simple Terms</h2>
                        </div>
                        <div class="card-content" style="padding: 16px; line-height: 1.6; font-size: 13px; color: var(--text-secondary);">
                            
                            <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: var(--text-primary);">What is a Model Context Protocol (MCP) Server?</h3>
                            <p style="margin-bottom: 12px;">
                                Model Context Protocol (MCP) is an open standard (introduced by Anthropic in late 2024) that makes it easier for AI systems to use external tools and data. You can think of MCP like a "USB-C port" for AI applications <a href="https://modelcontextprotocol.io" target="_blank" style="color: var(--text-primary);">modelcontextprotocol.io</a> <a href="https://seangoedecke.com" target="_blank" style="color: var(--text-primary);">seangoedecke.com</a>. Just as any device can plug into a USB-C port with a standard connector, an MCP server provides a common interface so that many different tools can plug into an AI (LLM) using the same method. An MCP server is essentially a program that provides one or more "tools" that an AI can use. These tools could do anything ‚Äì look up information, interact with a database, check the time, order a pizza, etc. ‚Äì but no matter what the tool does, it's exposed in a standardized way via MCP. This means the AI (or the app hosting the AI) can talk to any MCP server using the same protocol, instead of each tool having its own custom integration <a href="https://seangoedecke.com" target="_blank" style="color: var(--text-primary);">seangoedecke.com</a> <a href="https://seangoedecke.com" target="_blank" style="color: var(--text-primary);">seangoedecke.com</a>. The goal is to simplify tool integrations: once an application knows how to speak MCP, it can use any MCP-compliant tool without custom code for each new tool.
                            </p>

                            <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: var(--text-primary);">A Real-World Analogy</h3>
                            <p style="margin-bottom: 12px;">
                                To illustrate, imagine how we use USB devices on a computer. Without USB standards, every new gadget would need a different port or driver. USB made it simple ‚Äì one port for many devices. Similarly, before MCP, if someone wanted an AI to do something extra (like "order me a pizza" via a Domino's API), they had to write custom code and instructions for each AI platform <a href="https://seangoedecke.com" target="_blank" style="color: var(--text-primary);">seangoedecke.com</a>. Every AI model (OpenAI, Anthropic, etc.) had different formats for adding functions <a href="https://seangoedecke.com" target="_blank" style="color: var(--text-primary);">seangoedecke.com</a>. With MCP, a company like Domino's can just create an MCP server (a program that knows how to order pizzas) and anyone's AI app could plug it in and use it via the standard protocol <a href="https://seangoedecke.com" target="_blank" style="color: var(--text-primary);">seangoedecke.com</a>. In short, MCP servers give AI a universal "plug-in" system for tools.
                            </p>

                            <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: var(--text-primary);">Purpose of MCP Servers</h3>
                            <p style="margin-bottom: 12px;">
                                MCP servers were created to standardize how AI models get extra abilities or information. They address a big challenge: each AI platform historically had its own way of integrating tools or functions (for example, OpenAI's function calling schema vs. others). This fragmentation meant duplicate work and complexity. MCP solves this by defining one clear protocol for tools:
                            </p>
                            <p style="margin-bottom: 8px;"><strong>Ease of Integration:</strong> Developers only need to implement a tool once as an MCP server, and it can work with any AI client that supports MCP <a href="https://seangoedecke.com" target="_blank" style="color: var(--text-primary);">seangoedecke.com</a>. For AI app builders, adding a new capability is as simple as adding the server's address, rather than writing new code for each tool.</p>
                            <p style="margin-bottom: 8px;"><strong>Flexible Deployment:</strong> MCP servers can run locally or remotely, and can even run as simple command-line programs. For instance, some MCP servers are essentially just small scripts that you can run on your computer to expose a capability (like a calculator or a time lookup) to the AI <a href="https://seangoedecke.com" target="_blank" style="color: var(--text-primary);">seangoedecke.com</a>.</p>
                            <p style="margin-bottom: 12px;"><strong>Consistency:</strong> All communication between the AI (client) and the tool (server) uses JSON messages following the JSON-RPC 2.0 format <a href="https://modelcontextprotocol.io" target="_blank" style="color: var(--text-primary);">modelcontextprotocol.io</a> <a href="https://seangoedecke.com" target="_blank" style="color: var(--text-primary);">seangoedecke.com</a>. This means the format of requests and responses is predictable and doesn't change from tool to tool.</p>
                            <p style="margin-bottom: 12px;">
                                In summary, the purpose of MCP servers is to make it plug-and-play for AI to use external tools ‚Äì no matter who made the tool or what it does ‚Äì with security and standardization in mind <a href="https://descope.com" target="_blank" style="color: var(--text-primary);">descope.com</a>. This opens up a growing ecosystem of community-made tools that anyone can drop into their AI assistant or chatbot.
                            </p>

                            <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: var(--text-primary);">How Does an MCP Server Work?</h3>
                            <p style="margin-bottom: 12px;">
                                An MCP server works a bit like a mini API specialized for AI. Under the hood, it uses JSON-RPC 2.0, a lightweight protocol using JSON for requests and responses <a href="https://modelcontextprotocol.io" target="_blank" style="color: var(--text-primary);">modelcontextprotocol.io</a>. You don't need to know the low-level details, but essentially the communication goes like this:
                            </p>
                            <p style="margin-bottom: 8px;"><strong>Listing Available Tools:</strong> When an AI client connects to an MCP server, it first asks for the list of available tools (this is a JSON-RPC request called tools/list). The MCP server responds with a list of tools it offers, along with details about what each tool does and what kind of input it needs <a href="https://seangoedecke.com" target="_blank" style="color: var(--text-primary);">seangoedecke.com</a>. Think of this like asking, "What can you do?" and the server replying, "I have a time-check tool and a date-conversion tool," etc.</p>
                            <p style="margin-bottom: 12px;"><strong>Calling a Tool:</strong> Once the AI knows what tools exist, it can request to use one. It sends a JSON-RPC request tools/call with the name of the tool and the needed parameters. The MCP server then runs the tool (which might involve calling some API, running some code, accessing a database ‚Äì whatever that tool is designed to do) and returns the result as a JSON response <a href="https://seangoedecke.com" target="_blank" style="color: var(--text-primary);">seangoedecke.com</a>.</p>
                            
                            <p style="margin-bottom: 8px;"><strong>JSON In/Out:</strong> All this happens with JSON messages. For example, if the AI wants to get the current time in Warsaw, Poland using a "time" tool, it might send a JSON request like:</p>
                            <pre style="background: var(--bg-secondary); padding: 12px; border-radius: 6px; font-family: monospace; font-size: 12px; margin-bottom: 8px;">{ "name": "get_current_time", "arguments": { "timezone": "Europe/Warsaw" } }</pre>
                            <p style="margin-bottom: 8px;">The MCP server's tool will process that (check the current time in that timezone) and reply with a JSON result, perhaps:</p>
                            <pre style="background: var(--bg-secondary); padding: 12px; border-radius: 6px; font-family: monospace; font-size: 12px; margin-bottom: 12px;">{ "timezone": "Europe/Warsaw", "datetime": "2024-01-01T13:00:00+01:00", "is_dst": false }</pre>
                            <p style="margin-bottom: 12px;">
                                This reply gives the AI the info it asked for (current date-time in Warsaw) in a structured way <a href="https://glama.ai" target="_blank" style="color: var(--text-primary);">glama.ai</a>. The AI can then use that info to form a helpful answer to the user (for instance, telling the user the time in Warsaw). We'll discuss more about JSON structure in a later section, but the key point is that everything is communicated with standardized JSON data.
                            </p>

                            <p style="margin-bottom: 12px;"><strong>Tool Execution Environment:</strong> The MCP server can run wherever is appropriate. Some MCP servers are meant to run locally on your computer (especially if they need to access local files or hardware), communicating over stdin/stdout (standard input/output streams) <a href="https://levelup.gitconnected.com" target="_blank" style="color: var(--text-primary);">levelup.gitconnected.com</a> <a href="https://seangoedecke.com" target="_blank" style="color: var(--text-primary);">seangoedecke.com</a>. Others can run as a service on a remote server, communicating over HTTP. In either case, from the perspective of the AI client, it doesn't matter ‚Äì it speaks JSON to the MCP server and gets JSON back.</p>

                            <p style="margin-bottom: 12px;"><strong>MCP Client vs Server:</strong> It's useful to clarify terminology:</p>
                            <p style="margin-bottom: 8px;">The <strong>MCP Server</strong> is the tool provider (the program that has the tools, e.g. the "Time server" or "Pizza ordering server").</p>
                            <p style="margin-bottom: 8px;">The <strong>MCP Client</strong> is the component (usually part of the AI application) that connects to the server and relays messages. For example, Open WebUI or another chat interface would include an MCP client that knows how to send tools/list or tools/call requests and receive responses. This client acts on behalf of the AI model. The AI model itself might say something like "I want to use the tool X with these parameters," and the MCP client handles the actual communication to get the result.</p>
                            <p style="margin-bottom: 12px;">The <strong>Host</strong> or AI application is the overall system (e.g. the chat UI plus the model) that is using the client. In short, the host's MCP client talks to the MCP server <a href="https://modelcontextprotocol.io" target="_blank" style="color: var(--text-primary);">modelcontextprotocol.io</a>. But as a user, you mostly just need to know that the AI can now use the tool seamlessly.</p>

                            <p style="margin-bottom: 12px;">
                                When set up properly, using an MCP server is seamless: the AI will "call" the tool in the background when needed, then use the tool's output to respond to the user. For example, once a Time MCP server is connected, a user could ask "What time is it in Tokyo?" and the AI can call the get_current_time tool to fetch Tokyo time, then reply with the answer. From the user's perspective, it just looks like the AI magically knew the correct time!
                            </p>

                            <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: var(--text-primary);">Connecting to MCP Servers: Local vs Remote Methods</h3>
                            <p style="margin-bottom: 12px;">
                                Originally, MCP was designed to run tools locally (on the same machine as the AI client) using simple stdio (standard input/output) pipes. Over time, new methods were introduced to allow connecting to MCP servers running on different machines (or cloud services). Here's an overview of the different ways an AI can connect to an MCP server:
                            </p>

                            <p style="margin-bottom: 8px;"><strong>Local (Stdin/Stdout) Connection:</strong> This is the simplest method, used when the MCP server program runs on the same machine as the AI client. The client simply launches the MCP server process (for example, running a command on your PC) and then communicates by sending JSON messages to the process's stdin and reading responses from stdout <a href="https://levelup.gitconnected.com" target="_blank" style="color: var(--text-primary);">levelup.gitconnected.com</a>. This is very straightforward and doesn't require a network or HTTP ‚Äì it's just like two programs talking directly. Many reference MCP servers (especially those doing things on your local system) work this way. However, the limitation is obvious: it only works if you can run the tool on the same machine. If your AI interface is running on a remote server (or within a sandboxed environment like some web UIs), it might not be able to spawn local processes on your machine.</p>

                            <p style="margin-bottom: 8px;"><strong>Remote HTTP Connection with SSE (Server-Sent Events):</strong> To use MCP servers over a network (e.g., a tool running on a server in the cloud), the MCP spec provides an HTTP-based transport using Server-Sent Events (SSE) <a href="https://levelup.gitconnected.com" target="_blank" style="color: var(--text-primary);">levelup.gitconnected.com</a>. SSE is a technique that keeps an HTTP connection open so the server can continuously send events (messages) to the client. In the context of MCP:</p>
                            
                            <p style="margin-bottom: 8px;">Typically, the MCP server exposes an HTTP GET endpoint that a client connects to in order to open an event stream, and a POST endpoint for sending JSON-RPC messages (requests) to the server <a href="https://levelup.gitconnected.com" target="_blank" style="color: var(--text-primary);">levelup.gitconnected.com</a>.</p>
                            
                            <p style="margin-bottom: 12px;">The client first does a GET request to establish the SSE stream (like "open the channel"), and the server responds by keeping that connection open. Then the client can POST tool requests, and the server sends back responses as events over the stream <a href="https://levelup.gitconnected.com" target="_blank" style="color: var(--text-primary);">levelup.gitconnected.com</a>.</p>

                            <p style="margin-bottom: 12px;">This method was the initial way to do remote MCP and works, but it's a bit complex to set up (two endpoints and a need to manage a persistent connection). Also, not all environments handle SSE well (for instance, serverless or cloud functions might have trouble keeping a connection open).</p>

                            <p style="margin-bottom: 12px;"><strong>Why SSE?</strong> One benefit is that SSE allows streaming responses. If a tool is doing a long task or wants to send partial progress (e.g., a tool that streams back a large answer piece by piece), SSE can handle that by sending multiple events. SSE was essentially a workaround to push real-time messages over HTTP before more modern solutions like WebSockets or HTTP/2 streams were considered.</p>

                            <p style="margin-bottom: 8px;"><strong>Remote Connection with Streamable HTTP:</strong> Streamable HTTP is a newer method introduced (around early 2025) to simplify remote MCP connections. It essentially replaces the older SSE approach with a cleaner single-endpoint system <a href="https://levelup.gitconnected.com" target="_blank" style="color: var(--text-primary);">levelup.gitconnected.com</a> <a href="https://levelup.gitconnected.com" target="_blank" style="color: var(--text-primary);">levelup.gitconnected.com</a>. In streamable HTTP:</p>

                            <p style="margin-bottom: 8px;">The MCP server uses one HTTP path (URL) for both establishing connection and exchanging messages. The client still uses HTTP GET and POST, but the design is improved:</p>
                            <p style="margin-bottom: 8px;">A POST request can both initialize the session (if none exists) and send a message. The server can reply immediately with a response, and optionally upgrade to a streaming response if needed.</p>
                            <p style="margin-bottom: 12px;">A GET request to the same endpoint can be used to retrieve streaming updates if the server supports it (and it will respond with Content-Type: text/event-stream if SSE streaming is available on that endpoint) <a href="https://levelup.gitconnected.com" target="_blank" style="color: var(--text-primary);">levelup.gitconnected.com</a>. If the server doesn't support SSE streaming for that endpoint, it simply returns a "405 Method Not Allowed" for GET <a href="https://levelup.gitconnected.com" target="_blank" style="color: var(--text-primary);">levelup.gitconnected.com</a>.</p>

                            <p style="margin-bottom: 12px;">In simpler terms, streamable HTTP combines the handshake into one URL and uses HTTP more flexibly. There's no separate "connect" endpoint; you just start sending requests, and if a stream is needed the server handles it. This makes MCP servers easier to deploy behind standard HTTP infrastructure (e.g. behind load balancers or serverless platforms) and more resilient.</p>

                            <p style="margin-bottom: 12px;">At a user level, you likely won't see the difference ‚Äì it's an internal improvement. But if you encounter documentation referencing SSE vs. streamable HTTP, know that they serve the same purpose (enabling remote tool use), with streamable HTTP being the more modern approach. Many new MCP servers and clients support streamable HTTP as it was introduced in MCP spec version 1.10.0 (March 2025) <a href="https://levelup.gitconnected.com" target="_blank" style="color: var(--text-primary);">levelup.gitconnected.com</a>. SSE support may gradually fade as streamable HTTP covers the use-case more cleanly.</p>

                            <p style="margin-bottom: 12px;"><strong>Which method should you use?</strong> If you are running everything on your own computer (Open WebUI and the tool both locally), you might use the local stdio method or simply run the tool through the MCPO proxy (discussed below) which uses HTTP under the hood. If you need to connect to a tool running elsewhere (or want to host a tool for others), you'll likely use the HTTP methods. The good news is that tools often abstract this ‚Äì for example, Open WebUI's MCPO tool or other clients will handle the details. You mainly need to supply the correct URL or command and it will figure out whether to use SSE or streamable HTTP. Note: For security, remote transports support authentication. The MCP spec has an authorization mechanism for HTTP connections (so that you can restrict who can call your MCP server) <a href="https://levelup.gitconnected.com" target="_blank" style="color: var(--text-primary);">levelup.gitconnected.com</a>. However, not all client apps fully implement that yet. If you expose an MCP server over the internet, you should take care to secure it (e.g., run it behind an authenticated API). Tools like MCPO will by default allow you to leverage standard web security (since it uses HTTP, you can add API keys, HTTPS, etc.). And if you're only using it locally, security is less of a concern (it's not open to the world).</p>

                            <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: var(--text-primary);">Installing and Running MCP Servers (SSE, HTTP, Node, uv, npx‚Ä¶ Demystified)</h3>
                            <p style="margin-bottom: 12px;">
                                One point of confusion for newcomers is the variety of ways an MCP server can be set up and started. Let's break down the common scenarios and terms:
                            </p>

                            <p style="margin-bottom: 12px;"><strong>MCP Server Implementations:</strong> MCP is a protocol, and there are many actual server programs implementing it. They can be written in different languages. For example, Anthropic's reference SDK is in TypeScript (Node.js), but there are also Python implementations, etc. When you want to "add a tool," you will usually obtain an MCP server program (from an official repo, NPM, PyPI, or similar) that provides that tool's functionality.</p>

                            <p style="margin-bottom: 8px;"><strong>Running a Node.js-based MCP Server:</strong> If an MCP server is built with Node.js (JavaScript/TypeScript), it might be distributed via npm. You might see instructions like "run npx my-mcp-server" or "install with npm install -g then run a command".</p>

                            <p style="margin-bottom: 8px;"><strong>npx:</strong> This is a Node package runner that allows you to execute an npm package without installing it globally. For instance, if there is a package @modelcontextprotocol/inspector or a tool server, you could run it with npx in one go. npx will download the package if needed and execute the specified binary. This is convenient for trying out tools without cluttering your system with installed packages.</p>

                            <p style="margin-bottom: 12px;"><strong>Using Node directly:</strong> Alternatively, you might clone a repository or install a package and use the node command to start it (for example, node build/index.js if you built the project). This typically requires Node.js to be installed on your system. The details depend on the specific tool server's instructions.</p>

                            <p style="margin-bottom: 8px;"><strong>Running a Python-based MCP Server:</strong> Many MCP servers (especially ones in the official Model Context Protocol community repo) are in Python. They can often be installed via pip. For example, the Time tool server can be installed as pip install time-mcp-local <a href="https://glama.ai" target="_blank" style="color: var(--text-primary);">glama.ai</a>. After installing, you might run it with a command like python -m time_mcp_local or a specific entry-point script. However, there's a handy tool called uv that makes running Python CLI tools easier:</p>

                            <p style="margin-bottom: 8px;"><strong>uv and uvx:</strong> uv is a fast Python package manager/runner (written in Rust) that can create isolated environments and run packages quickly, similar in spirit to Node's npx (but for Python) <a href="https://docs.bswen.com" target="_blank" style="color: var(--text-primary);">docs.bswen.com</a> <a href="https://docs.bswen.com" target="_blank" style="color: var(--text-primary);">docs.bswen.com</a>. When you have uv installed, you get a command uvx which can run a Python tool in an ephemeral environment without you manually pip-installing it first. For example, uvx mcp-server-time --local-timezone=America/New_York would download and run the mcp-server-time package with that argument, all in one go <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a> <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>. It's exactly like running a script after a pip install, but uvx does it on the fly and caches it for next time. This is why many instructions recommend using uvx ‚Äì it saves steps and avoids dependency conflicts.</p>

                            <p style="margin-bottom: 12px;">If you don't want to use uvx, you can still do it the traditional way: e.g., pip install mcp-server-time then run mcp-server-time --local-timezone=... directly <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>. The result is the same, just a matter of convenience and speed.</p>

                            <p style="margin-bottom: 12px;"><strong>Using uvx vs pip:</strong> To summarize: pip install X installs a package X into your environment (which could be a virtualenv, etc.) and then you run it. uvx X will create an isolated environment for X, ensure it's installed (or install it temporarily), run it, and then tear down (though it caches for efficiency). So for one-off or quick runs, uvx is great. If you plan to keep a server running or develop it, you might do a normal pip install in a controlled environment. Both approaches are fine ‚Äì the MCP tools and MCPO support either <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a> <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>.</p>

                            <p style="margin-bottom: 12px;"><strong>Dependencies:</strong> If you're not very tech-savvy, the easiest path is usually:</p>
                            <p style="margin-bottom: 8px;">Install Python 3.8+ (if not already) and then install uv. You can install uv with pip install uv <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>. (In many cases, installing MCPO will also install uv as a dependency, which we'll discuss in a moment.)</p>
                            <p style="margin-bottom: 8px;">Use uvx to run any Python-based MCP server or MCPO itself, as shown in examples. This avoids dealing with Python virtual environments manually.</p>
                            <p style="margin-bottom: 12px;">If the tool server is only available for Node.js, ensure Node.js is installed, then use npx or npm as directed.</p>

                            <p style="margin-bottom: 12px;">For example, to run the Time server (which is Python-based) you could simply open a terminal and type: uvx mcp-server-time (plus any config flags it needs, like --local-timezone=Your/Timezone). To run a Node-based server (hypothetical example my-tool-server on npm), you might type: npx my-tool-server. Always check the documentation of the specific tool ‚Äì it will usually give a one-line command.</p>

                            <p style="margin-bottom: 12px;"><strong>Common MCP Server Examples:</strong> Official and community MCP servers include tools for things like time/date (as we discussed), file system access, web search, calculators, etc. For instance, the Time MCP Server provides two tools: get_current_time and convert_time (for converting between time zones) <a href="https://glama.ai" target="_blank" style="color: var(--text-primary);">glama.ai</a>. A Memory MCP Server might provide a way for the AI to store/retrieve information (like a short-term memory), a Filesystem MCP Server could allow reading or writing local files under controlled conditions, etc. These are often available via GitHub or packaged for easy install. The Open WebUI documentation references a repository of openapi-servers and suggests examples like Filesystem access, Git repo browsing, web search, etc., which can be run and then connected in the UI <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>. (Note: Some of those are directly OpenAPI servers rather than MCP, but the idea is similar from the user perspective ‚Äì MCPO can wrap MCP servers to appear as OpenAPI, and Open WebUI can also connect to any OpenAPI tool server.)</p>

                            <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: var(--text-primary);">MCPO ‚Äì The MCP-to-OpenAPI Proxy (Making MCP Servers Easy to Use)</h3>
                            <p style="margin-bottom: 12px;">
                                MCPO stands for MCP to OpenAPI proxy server (often just called the MCP proxy). It's a tool provided by Open WebUI (and available on GitHub) that acts as a bridge between the MCP world and regular web (OpenAPI/REST) world <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>. If that sounds technical, here's what it means in simple terms: MCP servers normally talk using that JSON-RPC protocol over stdin or SSE, which is a bit "inside baseball." Many modern apps and interfaces (including Open WebUI's UI) are more accustomed to calling HTTP REST APIs (with JSON). MCPO essentially wraps an MCP server in a standard web API. When you run MCPO and point it at an MCP server command, MCPO will start the MCP server in the background (via stdio) and simultaneously launch a local web server with a friendly REST API that corresponds to the MCP server's tools <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a> <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>. What you get with MCPO:
                            </p>

                            <p style="margin-bottom: 8px;"><strong>Standard REST Endpoints for Tools:</strong> Each tool from the MCP server becomes an HTTP endpoint. For example, if the MCP server has a tool called get_current_time, MCPO might expose an endpoint like GET /get_current_time or similar. You can call it with a normal HTTP request (or via an interactive API docs page) instead of dealing with JSON-RPC messages manually <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>.</p>

                            <p style="margin-bottom: 8px;"><strong>Auto-Generated Documentation (OpenAPI/Swagger):</strong> MCPO automatically generates an OpenAPI specification for the tools and serves a documentation UI. As soon as it's running, you can visit http://localhost:PORT/docs in your browser and see a Swagger UI listing all the available tools, their parameters, and allowing you to test them out. This is great for exploration and debugging. It's all created on the fly from the MCP server's own schema descriptions.</p>

                            <p style="margin-bottom: 8px;"><strong>HTTP and Security Benefits:</strong> Because MCPO speaks HTTP, you can integrate it with any system that understands web APIs. It also means you can use standard HTTP security measures (you could put it behind an HTTPS reverse proxy, add tokens, etc.). MCPO by default doesn't add authentication, but it makes it feasible to do so using common solutions. It eliminates the need to directly handle raw stdio or custom SSE connections in your client app <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>. Essentially, MCPO makes a local MCP tool behave like a typical web service, which is much easier for many applications to consume <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>.</p>

                            <p style="margin-bottom: 8px;"><strong>Remote Access and Cloud Deployments:</strong> Suppose you have Open WebUI running in the cloud, but you want to use a tool that runs on your local machine (which is impossible via direct stdio because the cloud can't reach into your PC). One solution is to run MCPO on your local machine with that tool, which turns it into a mini API server; then your cloud Open WebUI (or any cloud client) can connect to it over the internet (with appropriate network setup) <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a> <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>. Or vice versa ‚Äì you can deploy MCPO+tool in the cloud and connect your local UI to it. It decouples the location of the tool from the client.</p>

                            <p style="margin-bottom: 12px;"><strong>Zero Code Changes to Tools:</strong> You don't have to modify the MCP server code at all to use MCPO. MCPO figures out what tools the server provides by invoking MCP's built-in queries (like tools/list), then sets up everything automatically <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>. This means you can take any existing MCP server (even a custom one you wrote) and "publish" it as an API instantly.</p>

                            <p style="margin-bottom: 12px;">
                                In summary, MCPO is a translator: it speaks MCP on one side (to the tool) and speaks OpenAPI/HTTP on the other side (to the client). Open WebUI includes MCPO as a native tool, meaning they provide it for users to easily deploy tool servers <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>. In fact, Open WebUI recommends using the MCP-to-OpenAPI proxy approach because it leads to better integration and security in practice <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a> <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>.
                            </p>

                            <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: var(--text-primary);">Using MCPO: Installation and Running</h3>
                            <p style="margin-bottom: 12px;">Using MCPO is straightforward:</p>
                            <p style="margin-bottom: 12px;"><strong>Prerequisites:</strong> You need Python 3.8+ and ideally the uv tool (for convenience) <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>. If you installed Open WebUI's Python environment or followed their instructions, you might already have uv available.</p>
                            
                            <p style="margin-bottom: 8px;"><strong>Quickstart (Local):</strong> The quickest way to run MCPO is with uvx. For example, say you want to run the Time server via MCPO on port 8000:</p>
                            <p style="margin-bottom: 8px;">Command structure: uvx mcpo --port 8000 -- &lt;your_mcp_server_command&gt;. After the --, you put the command that would normally start your MCP server.</p>
                            <p style="margin-bottom: 8px;">Example: uvx mcpo --port 8000 -- uvx mcp-server-time --local-timezone=America/New_York. Let's break that down:</p>
                            <p style="margin-bottom: 8px;">The first uvx mcpo --port 8000 -- part tells uvx to launch the mcpo tool (the MCPO proxy server) listening on port 8000.</p>
                            <p style="margin-bottom: 12px;">After the --, we provide the MCP server command. Here we use uvx mcp-server-time --local-timezone=America/New_York which tells uvx to run the Time MCP server with a timezone parameter <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>. You could replace this with whatever MCP server you want to run (it could be another uvx command, or a direct command if already installed).</p>

                            <p style="margin-bottom: 12px;">When you run this, MCPO starts up, launches the time server, and you should see console logs for both. By default MCPO will bind to localhost (127.0.0.1) on the given port unless you specify --host 0.0.0.0 for external access.</p>

                            <p style="margin-bottom: 12px;">Now if you open a browser to http://localhost:8000/docs, you will see the Swagger UI with something like "Secure Time Utilities API" and endpoints for get_current_time and convert_time (if using the time server). You can even test them out there. Congratulations ‚Äì you have an HTTP API for your tool!</p>

                            <p style="margin-bottom: 12px;"><strong>Alternative: pip install:</strong> If you prefer, you can install MCPO via pip: pip install mcpo (and ensure the MCP server is installed or accessible). Then run it with the mcpo command: e.g., mcpo --port 8000 -- uvx mcp-server-time ... (the structure is the same, just calling the mcpo CLI) <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>. Using pip might be more suitable if you are setting up a persistent environment (like a server that will always have MCPO running).</p>

                            <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: var(--text-primary);">Conclusion and Next Steps</h3>
                            <p style="margin-bottom: 12px;">
                                We've covered a lot, so let's recap in plain language:
                            </p>
                            <p style="margin-bottom: 8px;">MCP (Model Context Protocol) is a standard way for AI to use external tools. It's like a universal adapter that lets any tool "plug in" to any AI that supports the protocol.</p>
                            <p style="margin-bottom: 8px;">MCP Servers are programs offering tools (functions) via this protocol. They use JSON messages (requests like list tools or call tool) to communicate. Real examples include tools for getting the time, searching files, converting formats, etc.</p>
                            <p style="margin-bottom: 8px;">Transport Methods: MCP servers can work locally through direct input/output, or over network using SSE or the newer streamable HTTP. These are just methods to send the JSON back and forth ‚Äì the end result is the same tools being accessible. Streamable HTTP is the simpler modern approach for remote access.</p>
                            <p style="margin-bottom: 8px;">Installation/Usage: Depending on the tool's implementation, you might run it with Node (using npx or node commands) or Python (using pip or uvx). Tools like uvx (for Python) and npx (for Node) exist to make running tools quick without full installation. Ensure you have the needed runtimes (Python, Node) and use Docker if you want to avoid messing with system environments or deploy in the cloud.</p>
                            <p style="margin-bottom: 8px;">MCPO (MCP Proxy to OpenAPI): This is your friend for integrating tools into UIs like Open WebUI. MCPO wraps any MCP server and makes it look like a standard web service (with a Swagger UI and all). It eliminates compatibility issues and allows easy cloud or cross-machine use. You run MCPO with a simple command and point it to your MCP server, and it provides a URL you can use to connect the tool.</p>
                            <p style="margin-bottom: 8px;">Open WebUI Integration: In Open WebUI, adding an MCPO-served tool is as easy as giving the URL in the settings. Once connected, the chat interface knows about the tool's functions. Using a model that supports tool usage, the AI can then call those functions to help answer questions or perform tasks. This can greatly expand what your AI assistant can do, from fetching real-time info to manipulating files.</p>
                            <p style="margin-bottom: 12px;">JSON Schema & Structure: All this works with JSON under the hood. While you as a user won't usually craft these JSON calls by hand (the system does it), understanding the format helps in troubleshooting. JSON is a structured text format ‚Äì always check your braces, brackets, quotes, and commas when dealing with config files. The schemas define what data goes in/out of tools, ensuring the AI and tool understand each other.</p>

                            <p style="margin-bottom: 12px;">
                                With this knowledge, you should be equipped to set up MCP servers and use MCPO confidently, even if you're not a programmer. Start with a simple example (the Time server is a good one to try). Run it via MCPO, connect it to Open WebUI, and ask your AI a question that needs that tool. Once you see it working, you'll likely get excited about adding more tools. Just remember to add one at a time and verify, so if something goes wrong you know which step caused it. Finally, always refer to documentation of the specific tool or Open WebUI's guides if you get stuck ‚Äì they often have step-by-step instructions (with screenshots) for these setups <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a> <a href="https://docs.openwebui.com" target="_blank" style="color: var(--text-primary);">docs.openwebui.com</a>. And the community forums or Discords are helpful if something isn't working. With a bit of patience, even non-tech-savvy users can greatly enhance their AI's capabilities through MCP and MCPO ‚Äì making your AI experience more powerful and personalized. Happy experimenting with MCP servers and enjoy your AI's new toolkit! üöÄ
                            </p>

                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script>
        // Server State Management - Connected to real backend
        let serverStates = {};
        let isPolling = false;

        // Theme Management with Persistence
        function toggleTheme() {
            const body = document.body;
            const currentTheme = body.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            body.setAttribute('data-theme', newTheme);

            // Update logo image based on theme
            const logoCircle = document.querySelector('.logo-circle');
            logoCircle.src = newTheme === 'dark' ? 'logos/OI-logo-d.png' : 'logos/OI-logo-light.png';

            // Persist theme preference
            localStorage.setItem('mcpo-theme', newTheme);

            updateThemeToggle();
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('mcpo-theme') || 'light';
            const body = document.body;
            body.setAttribute('data-theme', savedTheme);

            // Update logo image based on theme
            const logoCircle = document.querySelector('.logo-circle');
            if (logoCircle) {
                logoCircle.src = savedTheme === 'dark' ? 'logos/OI-logo-d.png' : 'logos/OI-logo-light.png';
            }

            updateThemeToggle();
        }

        function updateThemeToggle() {
            const theme = document.body.getAttribute('data-theme');
            const indicator = document.getElementById('theme-indicator');
            const label = document.getElementById('theme-label');
            if (!indicator || !label) return;
            if (theme === 'dark') {
                indicator.innerHTML = `<svg viewBox="0 0 24 24" width="16" height="16" aria-hidden="true"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg>`;
                label.textContent = 'Dark Theme';
            } else {
                indicator.innerHTML = `<svg viewBox=\"0 0 24 24\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill=\"currentColor\" d=\"M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z\"></path></svg>`;
                label.textContent = 'Light Theme';
            }
        }

        // Navigation Management
        const navItems = document.querySelectorAll('.nav-item');
        const pages = document.querySelectorAll('.page');

        navItems.forEach(item => {
            item.addEventListener('click', () => {
                const targetPage = item.getAttribute('data-page');
                
                // Update navigation
                navItems.forEach(nav => nav.classList.remove('active'));
                item.classList.add('active');
                
                // Update pages
                pages.forEach(page => page.classList.remove('active'));
                document.getElementById(`${targetPage}-page`).classList.add('active');
            });
        });

        // Server Expansion Management
        function toggleServerExpansion(serverName) {
            const serverItem = document.querySelector(`[data-server="${serverName}"]`);
            const dropdown = serverItem.querySelector('.tools-dropdown');
            
            serverItem.classList.toggle('expanded');
            dropdown.classList.toggle('expanded');
        }

        // Server Toggle Management - Connected to backend
        async function toggleServer(toggle, serverName) {
            const currentState = serverStates[serverName];
            const newEnabled = !currentState.enabled;
            
            // Optimistically update UI
            toggle.classList.toggle('on', newEnabled);
            
            // Call backend API
            const success = await toggleServerEnabled(serverName, newEnabled);
            
            if (success) {
                // Update local state
                serverStates[serverName].enabled = newEnabled;
                updateServerVisuals(serverName);
                updateStatusCounts();
            } else {
                // Revert UI on failure
                toggle.classList.toggle('on', !newEnabled);
                console.error(`Failed to toggle server ${serverName}`);
            }
        }

        // Tool Toggle Management - Connected to backend
        async function toggleTool(toolElement, toolName) {
            if (toolElement.classList.contains('inactive')) return;
            
            const serverName = toolElement.closest('[data-server]').getAttribute('data-server');
            const currentState = serverStates[serverName].tools[toolName];
            const newEnabled = !currentState;
            
            // Optimistically update UI
            if (newEnabled) {
                toolElement.classList.remove('disabled');
                toolElement.classList.add('enabled');
            } else {
                toolElement.classList.remove('enabled');
                toolElement.classList.add('disabled');
            }
            
            // Call backend API
            const success = await toggleToolEnabled(serverName, toolName, newEnabled);
            
            if (success) {
                // Update local state
                serverStates[serverName].tools[toolName] = newEnabled;
            updateStatusCounts();
            } else {
                // Revert UI on failure
                if (!newEnabled) {
                    toolElement.classList.remove('disabled');
                    toolElement.classList.add('enabled');
                } else {
                    toolElement.classList.remove('enabled');
                    toolElement.classList.add('disabled');
                }
                console.error(`Failed to toggle tool ${toolName} on server ${serverName}`);
            }
        }

        // Update Status Counts
        function updateStatusCounts() {
            let activeServers = 0;
            let enabledTools = 0;
            
            Object.entries(serverStates).forEach(([serverName, state]) => {
                if (state.enabled && state.connected) {
                    activeServers++;
                }
                
                if (state.enabled) {
                    Object.values(state.tools).forEach(toolEnabled => {
                        if (toolEnabled) enabledTools++;
                    });
                }
            });
            
            document.getElementById('server-count').textContent = `${activeServers} active`;
            document.getElementById('tool-count').textContent = `${enabledTools} enabled`;
            
            // Show/hide tools warning based on 40 tool limit
            const warningElement = document.getElementById('tools-warning');
            const totalToolsElement = document.getElementById('total-tools-count');
            
            if (enabledTools > 40) {
                totalToolsElement.textContent = enabledTools;
                warningElement.style.display = 'flex';
            } else {
                warningElement.style.display = 'none';
            }
        }

        // Navigate to config page from tools button
        function openConfigPage() {
            const targetPage = 'config';
            // update nav active state
            document.querySelectorAll('.nav-item').forEach(nav => {
                nav.classList.toggle('active', nav.getAttribute('data-page') === targetPage);
            });
            // show page
            document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
            document.getElementById(`${targetPage}-page`).classList.add('active');
        }

        // Real API Functions
        async function fetchServers() {
            try {
                const response = await fetch('/_meta/servers');
                const data = await response.json();
                if (data.ok) {
                    return data.servers;
                }
                console.error('Failed to fetch servers:', data);
                return [];
            } catch (error) {
                console.error('Error fetching servers:', error);
                return [];
            }
        }

        async function fetchServerTools(serverName) {
            try {
                const response = await fetch(`/_meta/servers/${serverName}/tools`);
                const data = await response.json();
                if (data.ok) {
                    return data.tools;
                }
                console.error(`Failed to fetch tools for ${serverName}:`, data);
                return [];
            } catch (error) {
                console.error('Error fetching tools:', error);
                return [];
            }
        }

        async function toggleServerEnabled(serverName, enabled) {
            try {
                const endpoint = enabled ? 'enable' : 'disable';
                const response = await fetch(`/_meta/servers/${serverName}/${endpoint}`, {
                    method: 'POST'
                });
                const data = await response.json();
                if (!data.ok) {
                    console.error(`Failed to ${endpoint} server ${serverName}:`, data);
                }
                return data.ok;
            } catch (error) {
                console.error(`Error toggling server ${serverName}:`, error);
                return false;
            }
        }

        async function toggleToolEnabled(serverName, toolName, enabled) {
            try {
                const endpoint = enabled ? 'enable' : 'disable';
                const response = await fetch(`/_meta/servers/${serverName}/tools/${toolName}/${endpoint}`, {
                    method: 'POST'
                });
                const data = await response.json();
                if (!data.ok) {
                    console.error(`Failed to ${endpoint} tool ${toolName}:`, data);
                }
                return data.ok;
            } catch (error) {
                console.error(`Error toggling tool ${toolName}:`, error);
                return false;
            }
        }

        async function reloadConfig() {
            try {
                const response = await fetch('/_meta/reload', { method: 'POST' });
                const data = await response.json();
                if (data.ok) {
                    console.log('Config reloaded successfully');
                    await updateServerStates();
                } else {
                    console.error('Failed to reload config:', data);
                }
                return data.ok;
            } catch (error) {
                console.error('Error reloading config:', error);
                return false;
            }
        }

        async function reinitServer(serverName) {
            try {
                const response = await fetch(`/_meta/reinit/${serverName}`, { method: 'POST' });
                const data = await response.json();
                if (data.ok) {
                    console.log(`Server ${serverName} reinitialized successfully`);
                    await updateServerStates();
                } else {
                    console.error(`Failed to reinitialize server ${serverName}:`, data);
                }
                return data.ok;
            } catch (error) {
                console.error(`Error reinitializing server ${serverName}:`, error);
                return false;
            }
        }

        // Real server state management
        async function updateServerStates() {
            try {
                const servers = await fetchServers();
                const newStates = {};
                
                for (const server of servers) {
                    const tools = await fetchServerTools(server.name);
                    const toolStates = {};
                    if (tools && tools.length > 0) {
                        tools.forEach(tool => {
                            toolStates[tool.name] = tool.enabled;
                        });
                    }
                    
                    newStates[server.name] = {
                        enabled: server.enabled,
                        connected: server.connected,
                        tools: toolStates,
                        basePath: server.basePath
                    };
                }
                
                serverStates = newStates;
                await renderServerList();
                updateStatusCounts();
            } catch (error) {
                console.error('Failed to update server states:', error);
            }
        }

        async function renderServerList() {
            const container = document.querySelector('.card-content');
            if (!container) return;
            
            container.innerHTML = '';
            
            for (const [serverName, state] of Object.entries(serverStates)) {
                const serverItem = createServerItem(serverName, state);
                container.appendChild(serverItem);
            }
        }

        function createServerItem(serverName, state) {
            const serverItem = document.createElement('div');
            serverItem.className = 'server-item';
            serverItem.setAttribute('data-server', serverName);
            
            const toolCount = Object.keys(state.tools).length;
            const enabledToolCount = state.enabled ? Object.values(state.tools).filter(Boolean).length : 0;
            const statusText = state.connected ? 'Connected ‚Ä¢ Ready' : 'Disconnected ‚Ä¢ Error';
            const toolText = state.connected ? `${enabledToolCount}/${toolCount} tools enabled` : `${toolCount} tools unavailable`;
            
            serverItem.innerHTML = `
                <div class="server-header" onclick="toggleServerExpansion('${serverName}')">
                    <div class="server-info">
                        <div class="server-name-row">
                            <div class="server-name">${serverName}</div>
                            <div class="status-beacon ${state.enabled && state.connected ? 'connected' : state.enabled ? 'error' : 'hidden'}"></div>
                        </div>
                        <div class="server-status">${statusText}</div>
                        <div class="tool-count">${toolText}</div>
                    </div>
                    <div class="server-controls">
                        <a href="/${serverName}/docs" target="_blank" class="btn" onclick="event.stopPropagation()">Docs</a>
                        <div class="toggle ${state.enabled ? 'on' : ''}" onclick="event.stopPropagation(); toggleServer(this, '${serverName}')"></div>
                        <svg class="expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="9,18 15,12 9,6"></polyline>
                        </svg>
                    </div>
                </div>
                <div class="tools-dropdown">
                    <div class="tools-grid">
                        ${Object.entries(state.tools).map(([toolName, enabled]) => 
                            `<span class="tool-tag ${enabled ? 'enabled' : 'disabled'} ${state.enabled && state.connected ? '' : 'inactive'}" onclick="toggleTool(this, '${toolName}')">${toolName}</span>`
                        ).join('')}
                    </div>
                </div>
            `;
            
            return serverItem;
        }

        function updateServerVisuals(serverName) {
            const serverItem = document.querySelector(`[data-server="${serverName}"]`);
            if (!serverItem) return;
            
            const state = serverStates[serverName];
            const beacon = serverItem.querySelector('.status-beacon');
            const tools = serverItem.querySelectorAll('.tool-tag');
            
            if (state.enabled && state.connected) {
                beacon.className = 'status-beacon connected';
                tools.forEach(tool => tool.classList.remove('inactive'));
            } else if (state.enabled && !state.connected) {
                beacon.className = 'status-beacon error';
                tools.forEach(tool => tool.classList.add('inactive'));
            } else {
                beacon.className = 'status-beacon hidden';
                tools.forEach(tool => tool.classList.add('inactive'));
            }
        }

        // Real log fetching
        async function fetchLogs() {
            try {
                const response = await fetch('/_meta/logs');
                const data = await response.json();
                if (data.ok) {
                    return data.logs;
                }
                console.error('Failed to fetch logs:', data);
                return [];
            } catch (error) {
                console.error('Error fetching logs:', error);
                return [];
            }
        }

        async function updateLogs() {
            const logs = await fetchLogs();
            const logsContent = document.getElementById('logs-content');
            if (!logsContent) return;
            
            logsContent.innerHTML = '';
            logs.forEach(log => {
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                logEntry.innerHTML = `
                    <span class="log-timestamp">${log.timestamp}</span>
                    <span class="log-level ${log.level.toLowerCase()}">${log.level}</span>
                    <span>${log.message}</span>
                `;
                logsContent.appendChild(logEntry);
            });
            
            logsContent.scrollTop = logsContent.scrollHeight;
        }

        // Real config management
        async function loadConfigContent() {
            try {
                const response = await fetch('/_meta/config/content');
                const data = await response.json();
                if (data.ok) {
                    const editor = document.getElementById('server-config-editor');
                    if (editor) {
                        editor.value = data.content;
                    }
                } else {
                    console.error('Failed to load config:', data);
                }
            } catch (error) {
                console.error('Error loading config:', error);
            }
        }

        async function saveConfigContent() {
            const editor = document.getElementById('server-config-editor');
            if (!editor) return;
            
            try {
                const response = await fetch('/_meta/config/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: editor.value })
                });
                const data = await response.json();
                if (data.ok) {
                    console.log('Config saved successfully');
                    await updateServerStates();
                } else {
                    console.error('Failed to save config:', data);
                }
            } catch (error) {
                console.error('Error saving config:', error);
            }
        }

        // Additional button functions
        function validateConfig() {
            const editor = document.getElementById('server-config-editor');
            if (!editor) return;
            
            try {
                JSON.parse(editor.value);
                alert('Configuration is valid JSON');
            } catch (e) {
                alert('Invalid JSON: ' + e.message);
            }
        }

        async function resetConfig() {
            if (confirm('Reset configuration to last saved version?')) {
                await loadConfigContent();
            }
        }

        async function saveRequirements() {
            const editor = document.querySelector('.config-editor[style*="min-height: 120px"]');
            if (!editor) return;
            
            try {
                const response = await fetch('/_meta/requirements/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: editor.value })
                });
                const data = await response.json();
                if (data.ok) {
                    console.log('Requirements saved successfully');
                } else {
                    console.error('Failed to save requirements:', data);
                }
            } catch (error) {
                console.error('Error saving requirements:', error);
            }
        }

        function installDependencies() {
            alert('Dependency installation would be triggered here (not implemented in backend)');
        }

        function clearLogs() {
            const logsContent = document.getElementById('logs-content');
            if (logsContent) {
                logsContent.innerHTML = '';
            }
        }

        async function restartAllServers() {
            try {
                const success = await reloadConfig();
                if (success) {
                    console.log('All servers restarted');
                } else {
                    console.error('Failed to restart servers');
                }
            } catch (error) {
                console.error('Error restarting servers:', error);
            }
        }

                // Load requirements content on init
        async function loadRequirementsContent() {
            try {
                const response = await fetch('/_meta/requirements/content');
                const data = await response.json();
                if (data.ok) {
                    const editor = document.querySelector('.config-editor[style*="min-height: 120px"]'); 
                    if (editor) {
                        editor.value = data.content;
                    }
                } else {
                    console.error('Failed to load requirements:', data);
                }
            } catch (error) {
                console.error('Error loading requirements:', error);
            }
        }

        // Polling for real-time updates
        function startPolling() {
            if (isPolling) return;
            isPolling = true;
            
            // Update server states every 5 seconds
            setInterval(async () => {
                await updateServerStates();
            }, 5000);
            
            // Update logs every 2 seconds
            setInterval(async () => {
                await updateLogs();
            }, 2000);
        }

        // Page Navigation with Persistence
        function showPage(pageId) {
            // Hide all pages
            document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(nav => nav.classList.remove('active'));
            
            // Show selected page
            const page = document.getElementById(pageId);
            const nav = document.querySelector(`[data-page="${pageId.replace('-page', '')}"]`);
            
            if (page) page.classList.add('active');
            if (nav) nav.classList.add('active');
            
            // Save current page
            localStorage.setItem('mcpo-current-page', pageId);
        }
        
        function loadCurrentPage() {
            const savedPage = localStorage.getItem('mcpo-current-page') || 'servers-page';
            showPage(savedPage);
        }
        
        // Update existing navigation clicks to use persistence
        document.addEventListener('click', function(e) {
            const navItem = e.target.closest('.nav-item[data-page]');
            if (navItem) {
                const pageId = navItem.getAttribute('data-page') + '-page';
                showPage(pageId);
            }
        });

                // Initialize with Persistence
        document.addEventListener('DOMContentLoaded', async () => {
            // Load persisted state first
            loadTheme();
            loadCurrentPage();
            
            // Then load dynamic content
            await updateServerStates();
            await updateLogs();
            await loadConfigContent();
            await loadRequirementsContent();
            startPolling();
        });
    </script>
</body>
</html>